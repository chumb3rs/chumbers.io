---
import ContentTypeSelection from '@/components/ContentTypeSelection';
import { ContentTypeEnum } from '@/data/utils';
import { slugify } from '@/utils';

type Props = {
    tags: string[];
    activeTag: string;
};
const { tags, activeTag = '' } = Astro.props;
---

<style>
    /* Container */
    .tag-scroll {
        position: relative;
        overflow-y: auto;
        overflow-x: auto;
        scroll-behavior: smooth;
    }

    /* Gradient edges */
    .fade-left,
    .fade-right {
        pointer-events: none;
        position: absolute;
        top: 0;
        bottom: 0;
        width: 40px;
        z-index: 10;
    }

    .fade-left {
        left: 0;
        background: linear-gradient(
            to right,
            rgba(255, 255, 255, 1),
            rgba(255, 255, 255, 0)
        );
    }

    .fade-right {
        right: 0;
        background: linear-gradient(
            to left,
            rgba(255, 255, 255, 1),
            rgba(255, 255, 255, 0)
        );
    }
</style>

<div class='relative mt-5 mb-8 mx-auto h-72'>
    <div
        id='tagScrollContainer'
        class='tag-scroll flex flex-col flex-wrap justify-center overflow-auto h-72'
        data-active={activeTag}
        client:load
    >
        {
            tags.map((tag) => (
                <ContentTypeSelection
                    text={tag}
                    slug={slugify(tag)}
                    activeOption={activeTag}
                    type={ContentTypeEnum.Tags}
                />
            ))
        }
    </div>

    <!-- Gradients -->
    <div id='fadeLeft' class='fade-left'></div>
    <div id='fadeRight' class='fade-right'></div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const container = document.getElementById('tagScrollContainer');
        const fadeLeft = document.getElementById('fadeLeft');
        const fadeRight = document.getElementById('fadeRight');

        if (!container) return; // nothing to do

        const updateFades = () => {
            if (!fadeLeft || !fadeRight) return;

            const maxScroll = container.scrollWidth - container.clientWidth;
            // Use a small epsilon to avoid flicker on fractional pixels
            const epsilon = 1;
            fadeLeft.style.opacity = container.scrollLeft > epsilon ? '1' : '0';
            fadeRight.style.opacity =
                container.scrollLeft < maxScroll - epsilon ? '1' : '0';
        };

        // Run once immediately (so fades are correct even before any scrolling)
        updateFades();

        // Update on scroll
        container.addEventListener('scroll', updateFades, { passive: true });

        // --- Now handle optional scroll-to-center for active tag ---
        const activeTag = container.dataset?.active;

        // If activeTag exists, try to center it (but don't abort fades if it doesn't)
        if (activeTag && activeTag.trim() !== '') {
            const activeEl = container.querySelector(
                `[data-slug="${activeTag}"]`
            );
            if (activeEl) {
                // Compute center scrollLeft
                const containerRect = container.getBoundingClientRect();
                const elRect = activeEl.getBoundingClientRect();

                const scrollLeft =
                    container.scrollLeft +
                    (elRect.left - containerRect.left) -
                    containerRect.width / 2 +
                    elRect.width / 2;

                container.scrollTo({ left: scrollLeft, behavior: 'smooth' });
                // fades may need a tiny delay because scroll is smooth; update after animation
                // Use a short timeout to recalc fades after the smooth scroll starts/completes
                setTimeout(updateFades, 160);
            } else {
                // element not found — still keep fades accurate (we already did)
                console.warn(
                    'activeTag present but no element found for',
                    activeTag
                );
            }
        } else {
            // No activeTag — ensure we start at left and fades are correct
            container.scrollTo({ left: 0 });
        }
    });
</script>
